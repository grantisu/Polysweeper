<!DOCTYPE html>
<html>
<head>
  <title>Polysweeper</title>
  <meta charset="UTF-8">
<style>

body { text-align: center; }

#theboard {
	border: 1px dashed black;
	margin: auto;
}

</style>

<script>

/* globals, yay */
var svgns = "http://www.w3.org/2000/svg";
var G;

/* ghetto style */
var gs = {
unclicked: 'fill:gray;stroke:#000;stroke-width:0.05;stroke-linejoin:bevel;',
clicked  : 'fill:white;fill-opacity:0;stroke:#000;stroke-width:0.01;stroke-linejoin:bevel;',
flagged  : 'fill:yellow;stroke:#000;stroke-width:0.05;stroke-linejoin:bevel;',
bomb     : 'fill:red;stroke:#000;stroke-width:0.05;stroke-linejoin:bevel;',
text     : 'font-size:0.4px;font-weight:bold;text-anchor:middle;',
color    : {
	1: '#229',
	2: '#282',
	3: '#762',
	4: '#922',
	5: '#600',
	6: '#626',
	7: '#146',
	8: '#243',
	9: '#222'
}
};


var shapes = {

Hex: {
	uH: Math.sin(Math.PI / 3.0),

	viewBoxFor: function (rows, cols) {
		return '0 0 ' + (0.75*cols + 0.5) + ' ' + (this.uH*rows + 0.7);
	},

	ptsStr: function (row, col) {
		var pstr = '';
		var xo = 0.55 + 0.75*col;
		var yo = 1.05 + this.uH*row;

		if (col & 1) { yo -= 0.5*this.uH; }

		for (var i = 0; i < 6; i++) {
			var x = xo + 0.5*Math.cos(i * Math.PI / 3.0);
			var y = yo + 0.5*Math.sin(i * Math.PI / 3.0);
			pstr += x+','+y+' ';
		}
		
		return pstr;
	},

	fitText: function (tNode, row, col) {
		tNode.setAttribute('x', 0.4 + 0.75*col);
		tNode.setAttribute('y', 1.15 + this.uH*(row - 0.5*(col & 1)));
	},

	getAdjacency: function (row, col) {
		if (col & 1) {
			/* shifted up */
			return [
				[row - 1, col - 1],
				[row    , col - 1],

				[row - 1, col    ],
				[row + 1, col    ],

				[row    , col + 1],
				[row - 1, col + 1]
			];
		} else {
			return [
				[row + 1, col - 1],
				[row    , col - 1],

				[row - 1, col    ],
				[row + 1, col    ],

				[row    , col + 1],
				[row + 1, col + 1]
			];
		}
	},
},

Sqr: {
	viewBoxFor: function (rows, cols) {
		return '0 0 ' + (cols+0.2) + ' ' + (rows+0.2);
	},

	ptsStr: function (row, col) {
		var pstr;
		var xo = col + 0.05;
		var yo = row + 0.05;

		return xo+','+yo+' '+(xo+1)+','+yo+' '+(xo+1)+','+(yo+1)+' '+xo+','+(yo+1);
	},

	fitText: function (tNode, row, col) {
		tNode.setAttribute('x', col + 0.55);
		tNode.setAttribute('y', row + 0.65);
	},

	getAdjacency: function (row, col) {
		return [
			[row - 1, col - 1],
			[row - 1, col    ],
			[row - 1, col + 1],

			[row    , col - 1],
			[row    , col + 1],

			[row + 1, col - 1],
			[row + 1, col    ],
			[row + 1, col + 1],
		];

	},

},

Tri: {
	viewBoxFor: function (rows, cols) {
		return '0 0 ' + 0.5*(cols+1) + ' ' + (rows+0.1);
	},

	ptsStr: function (row, col) {
		var pstr;
		var xo = 0.5*col;
		var yo = row + 0.05;

		if ((row + col) & 1) {
			pstr = (xo+0.0)+','+(yo+0.0)+' '+(xo+1.0)+','+(yo+0.0)+' '+(xo+0.5)+','+(yo+1.0);
		} else {
			pstr = (xo+0.0)+','+(yo+1.0)+' '+(xo+0.5)+','+(yo+0.0)+' '+(xo+1.0)+','+(yo+1.0);
		}
		
		return pstr;
	},

	fitText: function (tNode, row, col) {
		tNode.setAttribute('x', col*0.5 + 0.5);
		tNode.setAttribute('y', row + 0.8 - 0.3*((row+col) & 1));
	},

	getAdjacency: function (row, col) {
		if ((row+col) & 1) {
			/* pointing down */
			return [
				[row + 1, col - 1],
				[row + 1, col    ],
				[row + 1, col + 1],

				[row    , col - 2],
				[row    , col - 1],
				[row    , col + 1],
				[row    , col + 2],

				[row - 1, col - 2],
				[row - 1, col - 1],
				[row - 1, col    ],
				[row - 1, col + 1],
				[row - 1, col + 2]
			];
		} else {
			/* pointing up */
			return [
				[row - 1, col - 1],
				[row - 1, col    ],
				[row - 1, col + 1],

				[row    , col - 2],
				[row    , col - 1],
				[row    , col + 1],
				[row    , col + 2],

				[row + 1, col - 2],
				[row + 1, col - 1],
				[row + 1, col    ],
				[row + 1, col + 1],
				[row + 1, col + 2]
			];
		}

	},
},

};

function Game(shape, rows, cols, bombs, board, sbTime, sbScore) {
	this.shape   = shape;
	this.rows    = rows;
	this.cols    = cols;
	this.bombs   = bombs;
	this.board   = board;
	this.sbTime  = sbTime;
	this.sbScore = sbScore;

	if (isNaN(this.rows) || this.rows < 1 || this.rows > 100) {
		alert("Bad row count: "+this.rows);
		return null;
	}

	if (isNaN(this.cols) || this.cols < 1 || this.cols > 100) {
		alert("Bad col count: "+this.cols);
		return null;
	}

	if (isNaN(this.bombs) || this.rows * this.cols < 2 * this.bombs) {
		alert("Too many bombs!");
		return null;
	}

	this.bombMarked = 0;
	this.revealedCount = 0;
	this.mOffset = 0;
	this.nodesToReveal = [];
	this.nodesRevealed = {};

	this.board.innerHTML = '';
	this.sbTime.innerHTML = '';
	this.sbScore.innerHTML = '';

	this.msvg = document.createElementNS(svgns, 'svg');
	this.msvg.setAttribute('version', '1.1');
	this.msvg.setAttribute('viewBox', this.shape.viewBoxFor(this.rows, this.cols));

	for (var i = 0; i < this.rows; i++) {
		for (var j = 0; j < this.cols; j++) {
			this.msvg.appendChild(this.makePolyAt(i, j));
		}
	}

	for (var b = 0; b < this.bombs; b++) {
		this.addRandomBomb();
	}
}

Game.prototype.getNodeAt = function (row, col) {
	if (row >= 0 && col >= 0 && row < this.rows && col < this.cols) {
		var idx = this.mOffset + row*this.cols + col;
		return this.msvg.childNodes[idx];
	} else {
		return undefined;
	}
};

Game.prototype.mapAround = function (fMap, node) {
	if (!fMap) {
		fMap = function (a) { return a; };
	}
	
	var self = this;
	var f = function (a) {
		return fMap(self.getNodeAt(a[0], a[1]));
	};

	var adj = this.shape.getAdjacency(node.row, node.col);
	return adj.map(f);
};

function mPA_getp(pstr) {
	var p = document.createElementNS(svgns, 'polygon');
	return p;
}

function mPA_setp(p, pstr, r, c) {
	p.setAttribute('points', pstr);
	p.setAttribute('style', gs.unclicked);
	p.clickable = true;
	p.bomb = 0;
	p.row = r;
	p.col = c;
}

Game.prototype.makePolyAt = function (row, col) {
	var pstr = this.shape.ptsStr(row, col);
	/*
	var p = document.createElementNS(svgns, 'polygon');
	p.setAttribute('points', pstr);
	p.setAttribute('style', gs.unclicked);
	*/
	
	/*
	p.clickable = true;
	p.bomb = 0;
	p.row = row;
	p.col = col;
	*/
	var p = mPA_getp(pstr);
	mPA_setp(p, pstr, row, col);

	return p;
};

Game.prototype.addRandomBomb = function () {
	var row, col;
	var n = {bomb: true};
	while (!n || n.bomb) {
		row = Math.floor(Math.random()*this.rows);
		col = Math.floor(Math.random()*this.cols);
		n = this.getNodeAt(row, col);
	}
	n.bomb = 1;

	var incCount = function (n) { if (n) { n.count = (n.count || 0) + 1; } };
	this.mapAround(incCount, n);
};

Game.prototype.updateTime = function () {
	var dur = this.start ? Math.floor((Date.now() - this.start ) / 1000) : 0;
	this.sbTime.textContent = 'Time ' + dur;
};

Game.prototype.updateScore = function () {
	this.sbScore.textContent = 'UXB ' + (this.bombs - this.bombMarked);
};

Game.prototype.updateSize = function (ev) {
	var mH = 0.80*window.innerHeight;
	document.getElementById('theboard').firstChild.style.maxHeight = mH+'px';
};

Game.prototype.end = function () {
	clearInterval(this.sInt);
	this.sInt = undefined;
	this.msvg.onmouseup = undefined;
	this.msvg.oncontextmenu = undefined;
};

Game.prototype.boardClick = function (ev) {
	var el = ev.target;

	try{
		if (ev.button == 0) {
			this.revealNode(el);
		} else if (el.clickable && ev.button == 2) {
			if (el.flagged) {
				el.flagged = false;
				el.setAttribute('style', gs.unclicked);
				this.bombMarked -= 1;
			} else {
				el.flagged = true;
				el.setAttribute('style', gs.flagged);
				this.bombMarked += 1;
			}
		} else if (
		  !el.clickable &&
		  ev.button == 2 &&
		  el.count &&
		  this.mapAround(isFlagged, el).reduce(sum) == el.count
		) {
			this.mapAround(this.revealNode.bind(this), el);
		}

		this.updateScore();

	} catch (err) {
		alert(err);
		this.end();
	}
	return false;
};

Game.prototype.revealNode = function (el) {
	this.nodesToReveal.push(el);
	return this.revealNodeHelper();
};

Game.prototype.checkReveal = function (n) {
	var k = n ? n.row+':'+n.col : '0';
	var r = (n && n.clickable && !this.nodesRevealed[k]);
	this.nodesRevealed[k] = true;
	return r; 
};

Game.prototype.revealNodeHelper = function () {
	var visits = 0;
	while(this.nodesToReveal.length > 0) {
//console.log(this.nodesToReveal);
visits += 1;
		var el = this.nodesToReveal.pop();

		if (!(el && (el.clickable && !el.flagged))) { continue; }
		el.clickable = false;
		var row = el.row;
		var col = el.col;
		el.setAttribute('style', gs.clicked);

		if (el.bomb) {
			if (this.revealedCount == 0) {
				/* First click; take pity by moving the bomb elsewhere*/
				this.addRandomBomb();
				el.bomb = undefined;
				var decCount = function (n) { if (n) {--n.count;} };
				this.mapAround(decCount,el);
			} else {
				el.setAttribute('style', gs.bomb);
				if (this.sInt) {
					this.end();
					for (var j = 0; j < this.cols; j++) {
						for (var i = 0; i < this.rows; i++) {
							this.nodesToReveal.push(this.getNodeAt(i, j));
						}
					}
				}
			}
		}
		
		if (el.count) {
			var p = el.parentNode;
			var t = document.createElementNS(svgns, 'text');
			t.textContent = el.count;
			this.shape.fitText(t, row, col);
			t.setAttribute('style', gs.text + 'fill:' + (gs.color[el.count] || '#000')+';');
			/* make sure text appears beneath everything */
			p.insertBefore(t, p.firstChild);
			this.mOffset += 1;
		} else if (this.sInt) {
			var mNode = this.mapAround(null, el).filter(this.checkReveal.bind(this));
			this.nodesToReveal = this.nodesToReveal.concat(mNode);
		}

		if (this.sInt && ++this.revealedCount == (this.rows*this.cols - this.bombs)) {
			var dur = Date.now() - this.start;
			this.end();
			//alert("Winnar!\n"+(0.001*dur).toFixed(2)+" secs");
		}
	}
//console.log(visits);


	return false;
}

function isBomb(node) {
	if (node && node.bomb) {
		return 1;
	} else {
		return 0;
	}
}

function isFlagged(node) {
	if (node && node.flagged) {
		return 1;
	} else {
		return 0;
	}
}

function sum(a,b) { return a+b; }

function buildBoard() {

	var bStart = Date.now();

	if (G && G.sInt) { G.end(); }

	G = new Game(
		shapes[document.getElementById('shapeType').value],
		parseInt(document.getElementById('rowCount').value),
		parseInt(document.getElementById('colCount').value),
		parseInt(document.getElementById('bombCount').value),
		document.getElementById('theboard'),
		document.getElementById('thetime'),
		document.getElementById('thescore')
	);


	document.getElementById('thebutton').textContent = 'Restart';

	window.onresize = G.updateSize.bind(G);
	G.msvg.onmouseup = G.boardClick.bind(G);
	G.msvg.oncontextmenu = function (ev) { return false; };

	G.board.appendChild(G.msvg);
	G.updateSize();
	G.updateScore();
	G.updateTime();
	G.sInt = setInterval(G.updateTime.bind(G), 500);
	G.start = Date.now();

	bEnd = Date.now();

	console.log('Board built in '+(bEnd-bStart)+' msec');
}

</script>
</head>
<body onload='buildBoard()'>

<h1>Polysweeper</h1>

<div id='thetime'></div>
<div id='thescore'></div>
<div id='theboard'></div>
<label for='shapeType'>Shape</label>
<select name='shapeType' id='shapeType' value='Hex'>
  <option value='Hex'>Hexagon</option>
  <option value='Sqr'>Square</option>
  <option value='Tri'>Triangle</option>
</select>
<label for='bombCount'>Bombs</label>
<input type='text' name='bombCount' id='bombCount' value=49>
<label for='rowCount'>Rows</label>
<input type='text' name='rowCount' id='rowCount' value=16>
<label for='colCount'>Cols</label>
<input type='text' name='colCount' id='colCount' value=30>
<button id='thebutton' type='button' onclick='buildBoard()'>Start</button>

</body>
</html>
