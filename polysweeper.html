<!DOCTYPE html>
<html>
<head>
  <title>Polysweeper</title>
  <meta charset="UTF-8">
<style>

body { text-align: center; }

#theboard {
	border: 1px dashed black;
	margin: auto;
}

</style>

<script>

/* globals, yay */
var SVGNS = "http://www.w3.org/2000/svg";
var XLINKNS = "http://www.w3.org/1999/xlink";
var G;

/* ghetto style */
var gs = {
unclicked: 'fill:gray;stroke:#000;stroke-width:0.05;stroke-linejoin:bevel;',
clicked  : 'fill:white;fill-opacity:0;stroke:#000;stroke-width:0.01;stroke-linejoin:bevel;',
flagged  : 'fill:yellow;stroke:#000;stroke-width:0.05;stroke-linejoin:bevel;',
bomb     : 'fill:red;stroke:#000;stroke-width:0.05;stroke-linejoin:bevel;',
text     : 'font-size:0.4px;font-weight:bold;text-anchor:middle;',
color    : {
	1: '#229',
	2: '#282',
	3: '#762',
	4: '#922',
	5: '#600',
	6: '#626',
	7: '#146',
	8: '#243',
	9: '#222'
}
};


var shapes = {

Hex: {
	uW: 1.0,
	uH: Math.sin(Math.PI / 3.0),
	uPts: '0.5,0.0 0.25,0.433012701892 -0.25,0.433012701892 -0.5,0.0 -0.25,-0.433012701892 0.25,-0.433012701892',

	viewBoxFor: function (rows, cols) {
		return '0 0 ' + (0.75*cols + 0.5) + ' ' + (this.uH*rows + 0.7);
	},

	getRotation: function (row, col) {
		return 0;
	},

	getOffset: function (row, col) {
		var xo = 0.55 + 0.75*col;
		var yo = 1.05 + this.uH*row;

		if (col & 1) { yo -= 0.5*this.uH; }

		return [xo, yo];
	},

	getAdjacency: function (row, col) {
		if (col & 1) {
			/* shifted up */
			return [
				[row - 1, col - 1],
				[row    , col - 1],

				[row - 1, col    ],
				[row + 1, col    ],

				[row    , col + 1],
				[row - 1, col + 1]
			];
		} else {
			return [
				[row + 1, col - 1],
				[row    , col - 1],

				[row - 1, col    ],
				[row + 1, col    ],

				[row    , col + 1],
				[row + 1, col + 1]
			];
		}
	},
},

Pen: {
	uW: 1.7320508075689,
	uH: 1.3660254037845,
	uPts: '0.0,0.683012701892 0.866025403784,0.183012701892 0.366025403784,-0.683012701892 -0.366025403784,-0.683012701892 -0.866025403784,0.183012701892',

	viewBoxFor: function (rows, cols) {
		return '0 0 '+0.8660254037845*(cols+1.2)+' '+this.uW*(rows+0.7);
	},

	getRotation: function (row, col) {
		var r = 0;

		if (row & 1) {
			r = 270 - 90*(col & 3);
		} else {
			r = 90 - 90*(col & 3);
		}

		return r;
	},

	getOffset: function (row, col) {
		var xo = 1.2 - 0.366025403784*(row&1) + 0.683012701892*col;
		var yo = this.uW*(row + 1.1);

		if (row & 1) {
			xo += 0.366025403784*(2*Math.floor(col/4) + (col & 3 ? 1 : 0) + (col & 2 ? 1 : 0));
			yo -= 1.0490381056762499*(col & 1) - 0.366025403784*((col & 3) == 1);
		} else {
			xo += 0.366025403784*(2*Math.floor(col/4) + ((col & 3) == 3));
			yo -= 1.0490381056762499*(col & 1) - 0.366025403784*((col & 3) == 3);
		}

		return [xo, yo];
	},

	getAdjacency: function (row, col) {
		var c = col & 3;

		if (row & 1) {
			if (c == 0) {
				return [
					[row - 1, col    ],

					[row    , col - 2],
					[row    , col - 1],
					[row    , col + 1],

					[row + 1, col - 1],
					[row + 1, col    ],
					[row + 1, col + 1],
				];
			} else if (c == 1) {
				return [
					[row - 1, col - 1],
					[row - 1, col + 1],

					[row    , col - 2],
					[row    , col - 1],
					[row    , col + 1],
					[row    , col + 2],

					[row + 1, col    ],
				];
			} else if (c == 2) {
				return [
					[row - 1, col    ],

					[row    , col - 1],
					[row    , col + 1],
					[row    , col + 2],

					[row + 1, col - 1],
					[row + 1, col    ],
					[row + 1, col + 1],
				];
			} else {
				return [
					[row - 1, col - 1],
					[row - 1, col    ],
					[row - 1, col + 1],

					[row    , col - 2],
					[row    , col - 1],
					[row    , col + 1],
					[row    , col + 2],
				];
			}
		} else {
			if (c == 0) {
				return [
					[row - 1, col    ],

					[row    , col - 1],
					[row    , col + 1],
					[row    , col + 2],

					[row + 1, col - 1],
					[row + 1, col    ],
					[row + 1, col + 1],
				];
			} else if (c == 1) {
				return [
					[row - 1, col - 1],
					[row - 1, col    ],
					[row - 1, col + 1],

					[row    , col - 2],
					[row    , col - 1],
					[row    , col + 1],
					[row    , col + 2],
				];
			} else if (c == 2) {
				return [
					[row - 1, col    ],

					[row    , col - 2],
					[row    , col - 1],
					[row    , col + 1],

					[row + 1, col - 1],
					[row + 1, col    ],
					[row + 1, col + 1],
				];
			} else {
				return [
					[row - 1, col - 1],
					[row - 1, col + 1],

					[row    , col - 2],
					[row    , col - 1],
					[row    , col + 1],
					[row    , col + 2],

					[row + 1, col    ],
				];
			}
		}

	},
},

Sqr: {
	uW: 1.0,
	uH: 1.0,
	uPts: '-0.5,-0.5 0.5,-0.5 0.5,0.5 -0.5,0.5',

	viewBoxFor: function (rows, cols) {
		return '0 0 ' + (cols+0.2) + ' ' + (rows+0.2);
	},

	getRotation: function (row, col) {
		return 0;
	},

	getOffset: function (row, col) {
		return [col + 0.6, row + 0.6];
	},

	getAdjacency: function (row, col) {
		return [
			[row - 1, col - 1],
			[row - 1, col    ],
			[row - 1, col + 1],

			[row    , col - 1],
			[row    , col + 1],

			[row + 1, col - 1],
			[row + 1, col    ],
			[row + 1, col + 1],
		];

	},
},

Rho: {
	uW: 1.299038105676658,
	uH: 0.75,
	uPts: '-0.649519052838329,0 0.0,-0.375 0.649519052838329,0.0 0.0,0.375',

	viewBoxFor: function (rows, cols) {
		return '0 0 ' + (Math.floor(cols/2)+0.5) + ' ' + (1.125*rows+0.7);
	},

	getRotation: function (row, col) {
		return 120*((col-1) % 3);
	},

	getOffset: function (row, col) {
		var xo = 0.4 + 0.25*this.uW*col;
		var yo = 1.1 + 1.125*row;

		xo += 0.25*this.uW*(Math.floor(col / 3) + 2*(row & 1));
		yo -= ((col % 3) == 1 ? 0.5625 : 0);

		return [xo, yo];
	},

	getAdjacency: function (row, col) {
		var c = col % 3;
		var cshift = 3 * (row & 1);

		if (c == 0) {
			return [
				[row - 1, col - 3 + cshift],
				[row - 1, col - 1 + cshift],

				[row    , col - 2],
				[row    , col - 1],
				[row    , col + 1],
				[row    , col + 2],

				[row + 1, col - 2 + cshift],
				[row + 1, col - 1 + cshift],
				[row + 1, col     + cshift],
				[row + 1, col + 1 + cshift],
			];
		} else if (c == 1) {
			return [
				[row - 1, col - 4 + cshift],
				[row - 1, col - 2 + cshift],
				[row - 1, col - 1 + cshift],
				[row - 1, col + 1 + cshift],

				[row    , col - 3],
				[row    , col - 2],
				[row    , col - 1],
				[row    , col + 1],
				[row    , col + 2],
				[row    , col + 3],
			];
		} else {
			return [
				[row - 1, col - 2 + cshift],
				[row - 1, col     + cshift],

				[row    , col - 2],
				[row    , col - 1],
				[row    , col + 1],
				[row    , col + 2],

				[row + 1, col - 4 + cshift],
				[row + 1, col - 3 + cshift],
				[row + 1, col - 2 + cshift],
				[row + 1, col - 1 + cshift],
			];
		}
	},
},

Tri: {
	uW: 0.8660254037844386,
	uH: 0.75,
	uPts: '0.433012701892,-0.25 0.0,0.5 -0.433012701892,-0.25',

	viewBoxFor: function (rows, cols) {
		return '0 0 '+(0.5*this.uW*cols+0.6)+' '+(this.uH*rows+0.2);
	},

	getRotation: function (row, col) {
		return (row + col) & 1 ? 0 : 180;
	},

	getOffset: function (row, col) {
		var xo = 0.5*this.uW*col + 0.5;
		var yo = this.uH*row + 0.5;

		if ((row + col) & 1) {
			yo -= 0.333333333*this.uH;
		}

		return [xo, yo];
	},

	getAdjacency: function (row, col) {
		if ((row+col) & 1) {
			return [
			/* pointing down */
				[row + 1, col - 1],
				[row + 1, col    ],
				[row + 1, col + 1],

				[row    , col - 2],
				[row    , col - 1],
				[row    , col + 1],
				[row    , col + 2],

				[row - 1, col - 2],
				[row - 1, col - 1],
				[row - 1, col    ],
				[row - 1, col + 1],
				[row - 1, col + 2]
			];
		} else {
			return [
			/* pointing up */
				[row - 1, col - 1],
				[row - 1, col    ],
				[row - 1, col + 1],

				[row    , col - 2],
				[row    , col - 1],
				[row    , col + 1],
				[row    , col + 2],

				[row + 1, col - 2],
				[row + 1, col - 1],
				[row + 1, col    ],
				[row + 1, col + 1],
				[row + 1, col + 2]
			];
		}

	},
},

};

function Game(shape, rows, cols, bombs, board, sbTime, sbScore) {
	this.shape   = shape;
	this.rows    = rows;
	this.cols    = cols;
	this.bombs   = bombs;
	this.board   = board;
	this.sbTime  = sbTime;
	this.sbScore = sbScore;

	if (isNaN(this.rows) || this.rows < 1 || this.rows > 100) {
		alert("Bad row count: "+this.rows);
		return null;
	}

	if (isNaN(this.cols) || this.cols < 1 || this.cols > 100) {
		alert("Bad col count: "+this.cols);
		return null;
	}

	if (isNaN(this.bombs) || this.rows * this.cols < 2 * this.bombs) {
		alert("Too many bombs!");
		return null;
	}

	this.bombMarked = 0;
	this.revealedCount = 0;
	this.mOffset = 0;
	this.nodesToReveal = [];
	this.nodesRevealed = {};

	this.board.innerHTML = '';
	this.sbTime.innerHTML = '';
	this.sbScore.innerHTML = '';

	this.msvg = document.createElementNS(SVGNS, 'svg');
	this.msvg.setAttribute('version', '1.1');
	this.msvg.setAttribute('viewBox', this.shape.viewBoxFor(this.rows, this.cols));

	for (var i = 0; i < this.rows; i++) {
		for (var j = 0; j < this.cols; j++) {
			this.msvg.appendChild(this.makePolyAt(i, j));
		}
	}

	for (var b = 0; b < this.bombs; b++) {
		this.addRandomBomb();
	}
}

/* small helpers for mapAround method */

function isBomb(node) {
	return (node && node.bomb) ? 1 : 0;
}

function isFlagged(node) {
	return (node && node.flagged) ? 1 : 0;
}

function incCount(n) {
	if (n) { n.count = (n.count || 0) + 1; }
}

function decCount(n) {
	if (n) { n.count -= 1; }
}

function sum(a,b) {
	return a+b;
}

/* *** */


Game.prototype.getNodeAt = function (row, col) {
	if (row >= 0 && col >= 0 && row < this.rows && col < this.cols) {
		var idx = this.mOffset + row*this.cols + col;
		return this.msvg.childNodes[idx];
	} else {
		return undefined;
	}
};

Game.prototype.mapAround = function (fMap, node) {
	if (!fMap) {
		fMap = function (a) { return a; };
	}
	
	var self = this;
	var f = function (a) {
		return fMap(self.getNodeAt(a[0], a[1]));
	};

	var adj = this.shape.getAdjacency(node.row, node.col);
	return adj.map(f);
};

Game.prototype.makePolyAt = function (row, col) {
	var shape = this.shape;
	var [xo, yo] = shape.getOffset(row, col);
	var rot = shape.getRotation(row, col);

	var p = document.createElementNS(SVGNS, 'polygon');
	p.setAttribute('points', shape.uPts);
	p.setAttribute('transform',
		'translate('+xo+','+yo+')' +
		(rot ? ' rotate('+rot+')' : '')
	);
	p.setAttribute('style', gs.unclicked);
	
	p.clickable = true;
	p.bomb = 0;
	p.row = row;
	p.col = col;

	return p;
};

Game.prototype.addRandomBomb = function () {
	var row, col;
	var n = {bomb: true};
	while (!n || n.bomb) {
		row = Math.floor(Math.random()*this.rows);
		col = Math.floor(Math.random()*this.cols);
		n = this.getNodeAt(row, col);
	}
	n.bomb = 1;

	this.mapAround(incCount, n);
};

Game.prototype.updateTime = function () {
	var dur = this.start ? Math.floor((Date.now() - this.start ) / 1000) : 0;
	this.sbTime.textContent = 'Time ' + dur;
};

Game.prototype.updateScore = function () {
	this.sbScore.textContent = 'UXB ' + (this.bombs - this.bombMarked);
};

Game.prototype.updateSize = function (ev) {
	var mH = 0.80*window.innerHeight;
	document.getElementById('theboard').firstChild.style.maxHeight = mH+'px';
};

Game.prototype.end = function () {
	clearInterval(this.sInt);
	this.sInt = undefined;
	this.msvg.onmouseup = undefined;
	this.msvg.oncontextmenu = undefined;
};

Game.prototype.boardClick = function (ev) {
	var el = ev.target;

	try{
		if (ev.button == 0) {
			this.revealNode(el);
		} else if (el.clickable && ev.button == 2) {
			if (el.flagged) {
				el.flagged = false;
				el.setAttribute('style', gs.unclicked);
				this.bombMarked -= 1;
			} else {
				el.flagged = true;
				el.setAttribute('style', gs.flagged);
				this.bombMarked += 1;
			}
		} else if (
		  !el.clickable &&
		  ev.button == 2 &&
		  el.count &&
		  this.mapAround(isFlagged, el).reduce(sum) == el.count
		) {
			this.mapAround(this.revealNode.bind(this), el);
		}

		this.updateScore();

	} catch (err) {
		alert(err);
		this.end();
	}
	return false;
};

Game.prototype.revealNode = function (el) {
	this.nodesToReveal.push(el);
	var r = this.revealNodeHelper();
};

Game.prototype.checkReveal = function (n) {
	var k = n ? n.row+':'+n.col : '0';
	var r = (n && n.clickable && !this.nodesRevealed[k]);
	this.nodesRevealed[k] = true;
	return r; 
};

Game.prototype.addTextFor = function (node) {
	var p = node.parentNode;
	var shape = this.shape;

	var [xo, yo] = shape.getOffset(node.row, node.col);

	var t = document.createElementNS(SVGNS, 'text');
	t.textContent = node.count;
	t.setAttribute('style', gs.text + 'fill:' + (gs.color[node.count] || '#000')+';');
	t.setAttribute('transform', 'translate('+xo+','+(yo+0.125)+')');

	/* make sure text appears beneath everything */
	p.insertBefore(t, p.firstChild);
	this.mOffset += 1;
};

Game.prototype.revealNodeHelper = function () {
	var visits = 0;
	while(this.nodesToReveal.length > 0) {
		var el = this.nodesToReveal.pop();

		if (!(el && (el.clickable && !el.flagged))) { continue; }
		el.clickable = false;
		var row = el.row;
		var col = el.col;
		el.setAttribute('style', gs.clicked);

		if (el.bomb) {
			if (this.revealedCount == 0) {
				/* First click; take pity by moving the bomb elsewhere*/
				this.addRandomBomb();
				el.bomb = undefined;
				this.mapAround(decCount,el);
			} else {
				el.setAttribute('style', gs.bomb);
				if (this.sInt) {
					this.end();
					for (var j = 0; j < this.cols; j++) {
						for (var i = 0; i < this.rows; i++) {
							this.nodesToReveal.push(this.getNodeAt(i, j));
						}
					}
				}
			}
		}
		
		if (el.count) {
			this.addTextFor(el);
		} else if (this.sInt) {
			var mNode = this.mapAround(null, el).filter(this.checkReveal.bind(this));
			this.nodesToReveal = this.nodesToReveal.concat(mNode);
		}

		if (this.sInt && ++this.revealedCount == (this.rows*this.cols - this.bombs)) {
			var dur = Date.now() - this.start;
			this.end();
			alert("Winnar!\n"+(0.001*dur).toFixed(2)+" secs");
		}
	}

	return false;
}

function buildBoard() {

	var bStart = Date.now();

	if (G && G.sInt) { G.end(); }

	G = new Game(
		shapes[document.getElementById('shapeType').value],
		parseInt(document.getElementById('rowCount').value),
		parseInt(document.getElementById('colCount').value),
		parseInt(document.getElementById('bombCount').value),
		document.getElementById('theboard'),
		document.getElementById('thetime'),
		document.getElementById('thescore')
	);


	document.getElementById('thebutton').textContent = 'Restart';

	window.onresize = G.updateSize.bind(G);
	G.msvg.onmouseup = G.boardClick.bind(G);
	G.msvg.oncontextmenu = function (ev) { return false; };

	G.board.appendChild(G.msvg);
	G.updateSize();
	G.updateScore();
	G.updateTime();
	G.sInt = setInterval(G.updateTime.bind(G), 500);
	G.start = Date.now();

	bEnd = Date.now();

	console.log('Board built in '+(bEnd-bStart)+' msec');
}

</script>
</head>
<body onload='buildBoard()'>

<h1>Polysweeper</h1>

<div id='thetime'></div>
<div id='thescore'></div>
<div id='theboard'></div>
<label for='shapeType'>Shape</label>
<select name='shapeType' id='shapeType' value='Hex'>
  <option value='Hex'>Hexagon</option>
  <option value='Pen'>Pentagonal (Cairo)</option>
  <option value='Sqr'>Square</option>
  <option value='Rho'>Rhombus</option>
  <option value='Tri'>Triangle</option>
</select>
<label for='bombCount'>Bombs</label>
<input type='text' name='bombCount' id='bombCount' value=49>
<label for='rowCount'>Rows</label>
<input type='text' name='rowCount' id='rowCount' value=16>
<label for='colCount'>Cols</label>
<input type='text' name='colCount' id='colCount' value=30>
<button id='thebutton' type='button' onclick='buildBoard()'>Start</button>

</body>
</html>
