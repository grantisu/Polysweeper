<!DOCTYPE html>
<html>
<head>
  <title>Polysweeper</title>
  <meta charset="UTF-8">
  <style id='theCSS'>

body {
	background-color: #c0d5ef;
	font-weight: bold;
	text-align: center;
	font-family:
		"DejaVu Sans",
		"Bitstream Vera Sans",
		"Lucida Grande",
		"Lucida Sans",
		Corbel,
		Verdana,
		sans-serif;
	margin: 0;
	padding: 0 1em;
}

svg {
	max-width: 98%;
	margin: auto;
	display: block;
	box-shadow: 0 0 4em 4.4em #fff;
	background-color: #fff;
}

* {	/* box-shadow fix */
	position: relative;
	z-index: 1;
}

ul { list-style: none; }

li { display: inline-block; }

label { margin-left: 1.75em; }

input, select, button, #theCount, #theTime {
	background-color: #fff;
	border: 1px solid #000;
	box-shadow: 0.15em 0.15em 0.4em #333;
	border-radius: 0.3em;
}

button {
	box-shadow: inset 0 0 0.15em #594f3f, 0.15em 0.15em 0.4em #333;
	font-weight: bold;
}

button:active { background-color: #ffeec8; }

input {
	text-align: right;
	width: 2.5em;
}

select {
	text-align: left;
	min-width: 8em;
	max-width: 16em;
}

#theBoard {
	z-index: 0;

	padding: 0;
	margin: 0 auto;
}

#theButton {
	display: block;
	margin: 1em auto;
}

#theCount, #theTime, #hiScore {
	display: inline-block;
	margin: auto;
	padding: 0.1em 2em;
	min-width: 9em;
}

/* SVG style */

polygon {
	stroke:#000;
	stroke-width:0.02;
	stroke-linejoin:bevel;
}

.unclicked {
	fill: url(#grayMesa);
}

.clicked {
	fill:white;
	fill-opacity:0;
	stroke-width:0.01;
}

.flagged {
	fill: url(#yellowMesa);
}

.bomb {
	fill: url(#redMesa);
}

.ptext {
	font-size:0.4px;
	font-weight:bold;
	text-anchor:middle;
}

.ptext1 { fill: #229; }
.ptext2 { fill: #282; }
.ptext3 { fill: #762; }
.ptext4 { fill: #922; }
.ptext5 { fill: #600; }
.ptext6 { fill: #626; }
.ptext7 { fill: #146; }
.ptext8 { fill: #243; }
.ptext9 { fill: #222; }

.unclicked:hover {
	fill: #fff;
}

  </style>

  <script>

/* globals, yay */
var SVGNS = "http://www.w3.org/2000/svg";
var XLINKNS = "http://www.w3.org/1999/xlink";
var G;

var shapes = {

Hex: {
	name: 'Hexagon',
	uW: 1.0,
	uH: Math.sin(Math.PI / 3.0),
	uPts: [
		[0.5,0.0],
		[0.25,0.433012701892],
		[-0.25,0.433012701892],
		[-0.5,0.0],
		[-0.25,-0.433012701892],
		[0.25,-0.433012701892]
	],

	viewBoxFor: function (rows, cols) {
		return '0 0 ' + (0.75*cols + 0.5) + ' ' + (this.uH*rows + 0.75);
	},

	getRotation: function (row, col) {
		return 0;
	},

	getOffset: function (row, col) {
		var xo = 0.625 + 0.75*col;
		var yo = 1.05 + this.uH*row;

		if (col & 1) { yo -= 0.5*this.uH; }

		return [xo, yo];
	},

	getAdjacency: function (row, col) {
		if (col & 1) {
			/* shifted up */
			return [
				[row - 1, col - 1],
				[row    , col - 1],

				[row - 1, col    ],
				[row + 1, col    ],

				[row    , col + 1],
				[row - 1, col + 1]
			];
		} else {
			return [
				[row + 1, col - 1],
				[row    , col - 1],

				[row - 1, col    ],
				[row + 1, col    ],

				[row    , col + 1],
				[row + 1, col + 1]
			];
		}
	},
},

Pen: {
	name: 'Pentagon (Cairo)',
	uW: 1.7320508075689,
	uH: 1.3660254037845,
	uPts: [
		[0.0,0.683012701892],
		[0.866025403784,0.183012701892],
		[0.366025403784,-0.683012701892],
		[-0.366025403784,-0.683012701892],
		[-0.866025403784,0.183012701892]
	],

	viewBoxFor: function (rows, cols) {
		return '0 0 '+0.8660254037845*(cols+1.25)+' '+this.uW*(rows+0.7);
	},

	getRotation: function (row, col) {
		var r = 0;

		if (row & 1) {
			r = 270 - 90*(col & 3);
		} else {
			r = 90 - 90*(col & 3);
		}

		return r;
	},

	getOffset: function (row, col) {
		var xo = 1.125 - 0.366025403784*(row&1) + 0.683012701892*col;
		var yo = this.uW*(row + 1.1);

		if (row & 1) {
			xo += 0.366025403784*(2*Math.floor(col/4) + (col & 3 ? 1 : 0) + (col & 2 ? 1 : 0));
			yo -= 1.0490381056762499*(col & 1) - 0.366025403784*((col & 3) == 1);
		} else {
			xo += 0.366025403784*(2*Math.floor(col/4) + ((col & 3) == 3));
			yo -= 1.0490381056762499*(col & 1) - 0.366025403784*((col & 3) == 3);
		}

		return [xo, yo];
	},

	getAdjacency: function (row, col) {
		var c = col & 3;

		if (row & 1) {
			if (c == 0) {
				return [
					[row - 1, col    ],

					[row    , col - 2],
					[row    , col - 1],
					[row    , col + 1],

					[row + 1, col - 1],
					[row + 1, col    ],
					[row + 1, col + 1],
				];
			} else if (c == 1) {
				return [
					[row - 1, col - 1],
					[row - 1, col + 1],

					[row    , col - 2],
					[row    , col - 1],
					[row    , col + 1],
					[row    , col + 2],

					[row + 1, col    ],
				];
			} else if (c == 2) {
				return [
					[row - 1, col    ],

					[row    , col - 1],
					[row    , col + 1],
					[row    , col + 2],

					[row + 1, col - 1],
					[row + 1, col    ],
					[row + 1, col + 1],
				];
			} else {
				return [
					[row - 1, col - 1],
					[row - 1, col    ],
					[row - 1, col + 1],

					[row    , col - 2],
					[row    , col - 1],
					[row    , col + 1],
					[row    , col + 2],
				];
			}
		} else {
			if (c == 0) {
				return [
					[row - 1, col    ],

					[row    , col - 1],
					[row    , col + 1],
					[row    , col + 2],

					[row + 1, col - 1],
					[row + 1, col    ],
					[row + 1, col + 1],
				];
			} else if (c == 1) {
				return [
					[row - 1, col - 1],
					[row - 1, col    ],
					[row - 1, col + 1],

					[row    , col - 2],
					[row    , col - 1],
					[row    , col + 1],
					[row    , col + 2],
				];
			} else if (c == 2) {
				return [
					[row - 1, col    ],

					[row    , col - 2],
					[row    , col - 1],
					[row    , col + 1],

					[row + 1, col - 1],
					[row + 1, col    ],
					[row + 1, col + 1],
				];
			} else {
				return [
					[row - 1, col - 1],
					[row - 1, col + 1],

					[row    , col - 2],
					[row    , col - 1],
					[row    , col + 1],
					[row    , col + 2],

					[row + 1, col    ],
				];
			}
		}

	},
},

Sqr: {
	name: 'Square',
	uW: 1.0,
	uH: 1.0,
	uPts: [
		[-0.5,-0.5],
		[0.5,-0.5],
		[0.5,0.5],
		[-0.5,0.5]
	],

	viewBoxFor: function (rows, cols) {
		return '0 0 ' + (cols+0.2) + ' ' + (rows+0.2);
	},

	getRotation: function (row, col) {
		return 0;
	},

	getOffset: function (row, col) {
		return [col + 0.6, row + 0.6];
	},

	getAdjacency: function (row, col) {
		return [
			[row - 1, col - 1],
			[row - 1, col    ],
			[row - 1, col + 1],

			[row    , col - 1],
			[row    , col + 1],

			[row + 1, col - 1],
			[row + 1, col    ],
			[row + 1, col + 1],
		];

	},
},

Rho: {
	name: 'Rhombus',
	uW: 1.299038105676658,
	uH: 0.75,
	uPts: [
		[-0.649519052838329,0.0],
		[0.0,-0.375],
		[0.649519052838329,0.0],
		[0.0,0.375]
	],

	viewBoxFor: function (rows, cols) {
		return '0 0 ' + (this.uW*Math.floor((cols+2)/3)+0.75) + ' ' + (1.125*rows+0.7);
	},

	getRotation: function (row, col) {
		return 120*((col-1) % 3);
	},

	getOffset: function (row, col) {
		var xo = 0.375 + 0.25*this.uW*(col + Math.floor(col / 3));
		var yo = 1.1 + 1.125*row;

		xo += 0.5*this.uW*(row & 1);
		yo -= ((col % 3) == 1 ? 0.5625 : 0);

		return [xo, yo];
	},

	getAdjacency: function (row, col) {
		var c = col % 3;
		var cshift = 3 * (row & 1);

		if (c == 0) {
			return [
				[row - 1, col - 3 + cshift],
				[row - 1, col - 1 + cshift],

				[row    , col - 2],
				[row    , col - 1],
				[row    , col + 1],
				[row    , col + 2],

				[row + 1, col - 2 + cshift],
				[row + 1, col - 1 + cshift],
				[row + 1, col     + cshift],
				[row + 1, col + 1 + cshift],
			];
		} else if (c == 1) {
			return [
				[row - 1, col - 4 + cshift],
				[row - 1, col - 2 + cshift],
				[row - 1, col - 1 + cshift],
				[row - 1, col + 1 + cshift],

				[row    , col - 3],
				[row    , col - 2],
				[row    , col - 1],
				[row    , col + 1],
				[row    , col + 2],
				[row    , col + 3],
			];
		} else {
			return [
				[row - 1, col - 2 + cshift],
				[row - 1, col     + cshift],

				[row    , col - 2],
				[row    , col - 1],
				[row    , col + 1],
				[row    , col + 2],

				[row + 1, col - 4 + cshift],
				[row + 1, col - 3 + cshift],
				[row + 1, col - 2 + cshift],
				[row + 1, col - 1 + cshift],
			];
		}
	},
},

Tri: {
	name: 'Triangle',
	uW: 0.8660254037844386,
	uH: 0.75,
	uPts: [
		[0.433012701892,-0.25],
		[0.0,0.5],
		[-0.433012701892,-0.25]
	],

	viewBoxFor: function (rows, cols) {
		return '0 0 '+(0.5*this.uW*cols+0.5)+' '+(this.uH*rows+0.25);
	},

	getRotation: function (row, col) {
		return (row + col) & 1 ? 0 : 180;
	},

	getOffset: function (row, col) {
		var xo = 0.5*this.uW*col + 0.475;
		var yo = this.uH*row + 0.625;

		if ((row + col) & 1) {
			yo -= 0.333333333*this.uH;
		}

		return [xo, yo];
	},

	getAdjacency: function (row, col) {
		if ((row+col) & 1) {
			return [
			/* pointing down */
				[row + 1, col - 1],
				[row + 1, col    ],
				[row + 1, col + 1],

				[row    , col - 2],
				[row    , col - 1],
				[row    , col + 1],
				[row    , col + 2],

				[row - 1, col - 2],
				[row - 1, col - 1],
				[row - 1, col    ],
				[row - 1, col + 1],
				[row - 1, col + 2]
			];
		} else {
			return [
			/* pointing up */
				[row - 1, col - 1],
				[row - 1, col    ],
				[row - 1, col + 1],

				[row    , col - 2],
				[row    , col - 1],
				[row    , col + 1],
				[row    , col + 2],

				[row + 1, col - 2],
				[row + 1, col - 1],
				[row + 1, col    ],
				[row + 1, col + 1],
				[row + 1, col + 2]
			];
		}

	},
},

};

function Game(shape, rows, cols, bombs, board, sbTime, sbScore, hiScore) {
	this.shape   = shape;
	this.rows    = rows;
	this.cols    = cols;
	this.bombs   = bombs;
	this.board   = board;
	this.sbTime  = sbTime;
	this.sbScore = sbScore;

	if (isNaN(this.rows) || this.rows < 1 || this.rows > 100) {
		alert("Bad row count: "+this.rows);
		return null;
	}

	if (isNaN(this.cols) || this.cols < 1 || this.cols > 100) {
		alert("Bad col count: "+this.cols);
		return null;
	}

	if (isNaN(this.bombs) || this.rows * this.cols < 2 * this.bombs) {
		alert("Too many bombs!");
		return null;
	}

	this.bombMarked = 0;
	this.revealedCount = 0;
	this.nodesToReveal = [];
	this.nodesRevealed = {};
	this.numScores = 10;

	this.board.innerHTML = '';
	this.sbTime.innerHTML = '';
	this.sbScore.innerHTML = '';

	this.initSVG();

	for (var i = 0; i < this.rows; i++) {
		for (var j = 0; j < this.cols; j++) {
			this.pg.appendChild(this.makePolyAt(i, j));
		}
	}

	for (var b = 0; b < this.bombs; b++) {
		this.addRandomBomb();
	}

	this.svg.onmouseup = this.boardClick.bind(this);
	this.svg.oncontextmenu = function (ev) { return false; };

	hiScore.onclick = function (ev) { this.showHiScore(); }.bind(this);

	this.board.appendChild(this.svg);
}

/* small helpers for mapAround method */

function isBomb(node) {
	return (node && node.bomb) ? 1 : 0;
}

function isFlagged(node) {
	return (node && node.flagged) ? 1 : 0;
}

function incCount(n) {
	if (n) { n.count = (n.count || 0) + 1; }
}

function decCount(n) {
	if (n) { n.count -= 1; }
}

function sum(a,b) {
	return a+b;
}

/* *** */


Game.prototype.getNodeAt = function (row, col) {
	if (row >= 0 && col >= 0 && row < this.rows && col < this.cols) {
		var idx = row*this.cols + col;
		return this.pg.childNodes[idx];
	} else {
		return undefined;
	}
};

Game.prototype.mapAround = function (fMap, node) {
	if (!fMap) {
		fMap = function (a) { return a; };
	}
	
	var self = this;
	var f = function (a) {
		return fMap(self.getNodeAt(a[0], a[1]));
	};

	var adj = this.shape.getAdjacency(node.row, node.col);
	return adj.map(f);
};

Game.prototype.makePolyAt = function (row, col) {
	var shape = this.shape;
	var off = shape.getOffset(row, col);

	var rot = shape.getRotation(row, col);
	var cr = Math.cos(Math.PI * rot / 180.0);
	var sr = Math.sin(Math.PI * rot / 180.0);
	var pts = shape.uPts.map(function (p) {
		return (cr*p[0] - sr*p[1])+','+(sr*p[0] + cr*p[1]);
	}).join(' ');

	var p = document.createElementNS(SVGNS, 'polygon');
	p.setAttribute('points', pts);
	p.setAttribute('transform', 'translate('+off[0]+','+off[1]+')');
	
	p.clickable = true;
	p.bomb = 0;
	p.row = row;
	p.col = col;

	return p;
};

Game.prototype.addRandomBomb = function () {
	var row, col;
	var n = {bomb: true};
	while (!n || n.bomb) {
		row = Math.floor(Math.random()*this.rows);
		col = Math.floor(Math.random()*this.cols);
		n = this.getNodeAt(row, col);
	}
	n.bomb = 1;

	this.mapAround(incCount, n);
};

Game.prototype.updateTime = function () {
	var dur = this.start ? Math.floor((Date.now() - this.start ) / 1000) : 0;
	this.sbTime.textContent = 'Time ' + dur;
};

Game.prototype.updateScore = function () {
	this.sbScore.textContent = 'UXB ' + (this.bombs - this.bombMarked);
};

Game.prototype.updateSize = function (ev) {
	var mH = 0.80*window.innerHeight;
	document.getElementById('theBoard').firstChild.style.maxHeight = mH+'px';
};

Game.prototype.scoreKey = function () {
	return this.shape.name+':'+this.bombs+':'+this.rows+':'+this.cols;
};

Game.prototype.showHiScore = function (msg) {
	var scoreStr = msg ? msg+"\n\n" : '';
	var slist = localStorage.getItem(this.scoreKey());

	if (slist) {
		slist = JSON.parse(slist);
		scoreStr += "High Scores:\n"+slist.join("\n");
	} else {
		scoreStr += "No high scores yet!";
	}

	alert(scoreStr);
};

Game.prototype.end = function (score) {
	this.updateTime();
	clearInterval(this.sInt);

	if (score) {
		var sk = this.scoreKey();
		var slist = JSON.parse(localStorage.getItem(sk)) || [];
		var hs = slist.slice(-1)[0];
		
		if (!hs || score < hs) {
			slist.push(score);
			slist.sort(function (a, b) { return a - b; });
			if (slist.length > this.numScores) {
				slist.pop();
			}
			localStorage.setItem(sk, JSON.stringify(slist));
		}
	}

	this.sInt = undefined;
	this.svg.onmouseup = undefined;
	this.svg.oncontextmenu = undefined;
};

Game.prototype.boardClick = function (ev) {
	var el = ev.target;

	try{
		if (ev.button == 0) {
			this.revealNode(el);
		} else if (el.clickable && ev.button == 2) {
			el.classList.toggle('flagged');
			el.flagged = !el.flagged;
			this.bombMarked += el.flagged ? 1 : -1;
		} else if (
		  !el.clickable &&
		  ev.button == 2 &&
		  el.count &&
		  this.mapAround(isFlagged, el).reduce(sum) == el.count
		) {
			this.mapAround(this.revealNode.bind(this), el);
		}

		this.updateScore();

	} catch (err) {
		alert(err);
		this.end();
	}
	return false;
};

Game.prototype.revealNode = function (el) {
	this.nodesToReveal.push(el);
	var r = this.revealNodeHelper();
};

Game.prototype.checkReveal = function (n) {
	var k = n ? n.row+':'+n.col : '0';
	var r = (n && n.clickable && !this.nodesRevealed[k]);
	this.nodesRevealed[k] = true;
	return r; 
};

Game.prototype.addTextFor = function (node) {
	var p = this.svg;
	var shape = this.shape;

	var off = shape.getOffset(node.row, node.col);

	var t = document.createElementNS(SVGNS, 'text');
	t.textContent = node.count;
	t.setAttribute('class', 'ptext');
	if (node.count < 10) {
		t.classList.add('ptext' + node.count);
	}
	t.setAttribute('transform', 'translate('+off[0]+','+(off[1]+0.125)+')');

	/* make sure text appears beneath everything */
	p.insertBefore(t, p.lastChild);
};

Game.prototype.revealNodeHelper = function () {
	var visits = 0;
	while(this.nodesToReveal.length > 0) {
		var el = this.nodesToReveal.pop();

		if (!(el && (el.clickable && !el.flagged))) { continue; }
		el.clickable = false;
		var row = el.row;
		var col = el.col;
		el.setAttribute('class', 'clicked');

		if (el.bomb) {
			if (this.revealedCount == 0) {
				/* First click; take pity by moving the bomb elsewhere*/
				this.addRandomBomb();
				el.bomb = undefined;
				this.mapAround(decCount,el);
			} else {
				el.setAttribute('class', 'bomb');
				if (this.sInt) {
					this.end();
					for (var j = 0; j < this.cols; j++) {
						for (var i = 0; i < this.rows; i++) {
							this.nodesToReveal.push(this.getNodeAt(i, j));
						}
					}
				}
			}
		}
		
		if (el.count) {
			this.addTextFor(el);
		} else if (this.sInt) {
			var mNode = this.mapAround(null, el).filter(this.checkReveal.bind(this));
			this.nodesToReveal = this.nodesToReveal.concat(mNode);
		}

		if (this.sInt && ++this.revealedCount == (this.rows*this.cols - this.bombs)) {
			var dur = Date.now() - this.start;
			var score = (0.001*dur).toFixed(2);
			this.end(score);

			this.showHiScore("Winner!\nScore: "+score+" secs");
		}
	}

	return false;
}

Game.prototype.initSVG = function () {
	var divHack = document.createElement('div');
	divHack.innerHTML = "" + 
"<svg version='1.1' viewBox='"+this.shape.viewBoxFor(this.rows, this.cols)+"' preserveAspectRatio='xMidYMin meet'>" + 
	"<link rel='stylesheet' href='#theCSS' type='text/CSS' />" +
	"<defs>" +
		"<radialGradient id='grayMesa' r='0.75' fx='0.125' fy='0.125'>" +
			"<stop offset='0%' stop-color='#888888' />" +
			"<stop offset='50%' stop-color='#777778' />" +
			"<stop offset='100%' stop-color='#444448' />" +
		"</radialGradient>" +
		"<radialGradient id='yellowMesa' r='0.75' fx='0.125' fy='0.125'>" +
			"<stop offset='0%' stop-color='#e5e589' />" +
			"<stop offset='50%' stop-color='#cfcf63' />" +
			"<stop offset='100%' stop-color='#444422' />" +
		"</radialGradient>" +
		"<radialGradient id='redMesa' r='0.75' fx='0.5' 'fy=0.5'>" +
			"<stop offset='0%' stop-color='#f00' />" +
			"<stop offset='100%' stop-color='#444448' />" +
		"</linearGradient>" +
	"</defs>" +
"</svg>";

	this.pg = document.createElementNS(SVGNS, 'g');
	this.pg.setAttribute('fill', 'url(#grayMesa)');

	this.svg = divHack.firstChild;
	this.svg.appendChild(this.pg);
};

function buildBoard() {

	var bStart = Date.now();

	if (G && G.sInt) { G.end(); }

	G = new Game(
		shapes[document.getElementById('shapeType').value],
		parseInt(document.getElementById('rowCount').value),
		parseInt(document.getElementById('colCount').value),
		parseInt(document.getElementById('bombCount').value),
		document.getElementById('theBoard'),
		document.getElementById('theTime'),
		document.getElementById('theCount'),
		document.getElementById('hiScore')
	);

	document.getElementById('theButton').textContent = 'Reset';

	window.onresize = G.updateSize.bind(G);
	G.updateSize();
	G.updateScore();
	G.updateTime();
	G.sInt = setInterval(G.updateTime.bind(G), 300);
	G.start = Date.now();

	bEnd = Date.now();

	console.log('Board built in '+(bEnd-bStart)+' msec');
}

function initPage() {
	var st = document.getElementById('shapeType');

	for (var s in shapes) {
		var o = document.createElement('option');
		o.setAttribute('value', s);
		o.textContent = shapes[s].name;
		st.appendChild(o);
	}

	st.value = localStorage.getItem('lastShape') || 'Hex';
	st.onchange = function (ev) { localStorage.setItem('lastShape', ev.target.value); };
	buildBoard();
}

  </script>
</head>
<body onload='initPage()'>

<h1>Polysweeper</h1>

<ul>
<li>
<label for='shapeType'>Shape</label>
<select name='shapeType' id='shapeType' value='Hex'></select>
</li>
<li>
<label for='bombCount'>Bombs</label>
<input type='text' name='bombCount' id='bombCount' value=49>
</li>
<li>
<label for='rowCount'>Rows</label>
<input type='text' name='rowCount' id='rowCount' value=16>
</li>
<li>
<label for='colCount'>Cols</label>
<input type='text' name='colCount' id='colCount' value=30>
</li>
</ul>

<button id='theButton' type='button' onclick='buildBoard()'>Start</button>
<div id='theBoard'></div>
<div id='theTime'></div>
<div id='theCount'></div>
<button id='hiScore' type='button'>High Scores</button>

</body>
</html>
